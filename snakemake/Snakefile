# vim: syntax=python

# These should probably be converted to subworkflows at some point.
# For now, just for organizing rules into manageably-sized files.
include: "snakefile.callable_regions"
include: "snakefile.phasing"
include: "snakefile.abmodel"
include: "snakefile.permute"
include: "snakefile.mosaic_snv"

# Different GATK versions and calling methods are available. The
# version used in the publication is 'gatk3_joint'. Other versions
# are experimental.
# N.B. various utility functions rely on GATK3. All of these except
# CombineVariants, used to join phased genotypes in snakefile.phasing,
# port easily to GATK4 equivalents.
if config['gatk'] == 'gatk3_joint':
    include: "snakefile.gatk3_joint"
    print("Using GATK version 3 with joint calling")
    print("This method was used in the publication.")
    print("WARNING: joint calling requires rerunning GATK for cross-sample analysis of SNVs (mutation signatures) and indels. This can take an extremely long time to run for large sample sets.")
elif config['gatk'] == 'gatk4_joint':
    include: "snakefile.gatk4_joint"
    print("Using GATK version 4 with joint calling")
    print("WARNING: joint calling requires rerunning GATK for cross-sample analysis of SNVs (mutation signatures) and indels. This can take an extremely long time to run for large sample sets.")
elif config['gatk'] == 'gatk4_gvcf':
    include: "snakefile.gatk4_gvcf"
    print("Using GATK version 4 with GVCF calling (EXPERIMENTAL)!")
else:
    raise RuntimeError("unrecognized GATK version and strategy: " + config['gatk'])


# Perform genotyping at ALL sites, not just somatic candidates.
# MUCH slower, but allows more data exploration and/or debugging
# of somatic filters.
if config['score_all_sites']:
    include: "snakefile.allsites"
else:
    include: "snakefile.candidates_only"


wildcard_constraints:
    chr='|'.join(str(x) for x in config['chrs']),
    gatk_chunk="\d+",
    gatk_mmq="\d+",
    muttype="snv|indel|mosaic_snv",
    phaser="shapeit|eagle"


# Determine the analyses to run, depending on which options
# were selected by the user.
def determine_pipeline_output(wildcards):
    prf = ''
    d = dict()

    # Somatic SNVs
    if config['analyze_snvs']:
        print("adding somatic SNVs to schedule")
        d['somatic_genotypes'] = expand("snv/{sample}/somatic_genotypes.rda",
            sample=config['sc_bams'].keys())
        d['hsnp_spikein_genotypes'] = expand("snv/{sample}/hsnp_spikein_genotypes.rda",
            sample=config['sc_bams'].keys())
        if config['permute']:
            d['permuted_snvs'] = expand("snv/{sample}/permuted_sites.rda",
                sample=config['sc_bams'].keys())

    # Somatic indels
    if config['analyze_indels']:
        print("adding somatic indels to schedule")
        d['indel_somatic_genotypes'] = expand("indel/{sample}/somatic_genotypes.pon_filter.rda",
            sample=config['sc_bams'].keys())
        d['indel_hsnp_spikein_genotypes'] = expand("indel/{sample}/hsnp_spikein_genotypes.rda",
            sample=config['sc_bams'].keys())
        if config['permute']:
            d['permuted_indels'] = expand("indel/{sample}/permuted_sites.rda",
                sample=config['sc_bams'].keys())

    # Mosaic SNVs
    if config['analyze_mosaic_snvs']:
        print("adding mosaic SNVs to schedule")
        d['mosaic_genotypes'] = expand("mosaic_snv/{sample}/somatic_genotypes.rda",
            sample=config['sc_bams'].keys())

    # Find bases passing minimum depth thresholds
    if config['callable_regions']:
        print("adding region callability to schedule")
        d['callable_beds'] = \
            expand("callable_regions/{sample}/callable_regions.rda",
                sample=config['sc_bams'].keys())

    return d


rule all:
    input:
        unpack(determine_pipeline_output)


# Unlike SNVs, training indels are not used to fit AB mdoel parameters.
rule training_indels_helper:
    input:
        joint_vcf="gatk/hc_raw.mmq60.vcf.gz",
        phased_vcf=config['phaser'] + "/phased_indels.vcf.gz"
    output:
        tab="indel/{sample}/hsnps.tab",
        combined_vcf="indel/{sample}/hsnps.vcf",
        tmp_vcf="indel/{sample}/hsnps_helper_tmp.vcf",
    params:
        sn="{sample}"
    resources:
        mem=4000
    shell:
        "bcftools merge "
        "    -o {output.tmp_vcf} "
        "    {input.joint_vcf} {input.phased_vcf} ; "
        "gatk SelectVariants"
        "    --java-options '-Xmx3G -Xms3G'"
        "    -R {config[ref]}"
        "    -V {output.tmp_vcf}"
        "    --sample-name {params.sn}"
        "    --sample-name phasedgt"
        "    --exclude-non-variants"
        "    --select-type-to-include INDEL"
        "    -select 'vc.getGenotype(\"'{params.sn}'\").isCalled()'"
        "    -select 'vc.getGenotype(\"phasedgt\").isCalled()'"
        "    -select 'vc.isBiallelic()'"
        "    -O {output.combined_vcf} ; "
        "{config[scripts]}/totab.phase.sh {output.combined_vcf} {output.tab}"


rule training_indels:
    input:
        "indel/{sample}/hsnps.tab"
    output:
        rda="indel/{sample}/training.rda"
    resources:
        mem=4000
    script:
        "scripts/training_indels_script.R"


rule scansnv_vcftotab:
    input:
        "gatk/hc_raw.mmq{gatk_mmq}.vcf"
    output:
        vcf="{muttype}/mmq{gatk_mmq}.vcf",
        tab="{muttype}/mmq{gatk_mmq}.tab"
    params:
        stoi_type=lambda wildcards:
            'SNP' if wildcards.muttype == 'snv' else \
                ('INDEL' if wildcards.muttype == 'indel' else 'ERROR_NOT_SUPPORTED'), #\
                    #raise RuntimeException('muttype must be snv or indel, got ' + wildcards.muttype)),
        totab_script=lambda wildcards:
            'totab.sh' if wildcards.muttype == 'snv' else \
                ('totab.indel.sh' if wildcards.muttype == 'indel' else 'ERROR_NOT_SUPPORTED') #\
                    #raise RuntimeException('muttype must be snv or indel, got ' + wildcards.muttype))
    resources:
        mem=4000
    shell:
        "gatk SelectVariants"
        "   --java-options '-Xmx3G -Xms3G'"
        "   -R {config[ref]}"
        "   -V {input}"
        "   --select-type-to-include {params.stoi_type} "
        "   --restrict-alleles-to BIALLELIC"
        "   --exclude-non-variants"
        "   -select 'vc.getGenotype(\"{config[bulk_sample]}\").isCalled()'"
        "   -O {output.vcf} ; "
        "{config[scripts]}/{params.totab_script} {output.vcf} {output.tab}"


rule scansnv_sample_hsnps:
    input:
        vcf=lambda wildcards:
            config['phaser'] + ("/phased_hsnps.vcf" if wildcards.muttype == 'snv' else "/phased_indels.vcf"),
        somatic_pos="{muttype}/somatic_positions.%s{chr}.tab" % config['chr_prefix']
    output:
        rda="{muttype}/hsnp_spikein_positions.%s{chr}.rda" % config['chr_prefix'],
        resample_rda="{muttype}/hsnp_spikein_resample.%s{chr}.rda" % config['chr_prefix'],
        pdf="{muttype}/hsnp_spikein_resample.%s{chr}.pdf" % config['chr_prefix'],
        tab="{muttype}/hsnp_spikein_positions.%s{chr}.tab" % config['chr_prefix']
    resources:
        mem=8000
    script:
        "scripts/scansnv_sample_hsnps_script.R"


rule scansnv_count_cigars:
    input:
        sites="{muttype}/{vartype}_positions.%s{chr}.tab" % config['chr_prefix'],
        bam=lambda wildcards: config['bam_map'][wildcards.sample]
    output:
        tab="{muttype}/{sample}/{vartype}_cigars.%s{chr}.tab" % config['chr_prefix']
    benchmark:
        "{muttype}/{sample}/benchmark_{vartype}_cigars.%s{chr}.tsv" % config['chr_prefix']
    resources:
        mem=1000
    shell:
        "{config[scripts]}/count_cigars.py {input.bam} {input.sites} {output.tab}"


rule scansnv_cigar_gather:
    input:
        lambda wildcards:
            expand("{muttype}/{sample}/{vartype}_cigars.{chr_prefix}{chr}.tab",
                muttype=wildcards.muttype,
                sample=wildcards.sample,
                chr_prefix=config['chr_prefix'],
                vartype=wildcards.vartype, chr=config['chrs'])
    output:
        "{muttype}/{sample}/{vartype}_cigars.tab"
    resources:
        mem=1000
    script:
        "scripts/scansnv_cigar_gather_script.R"


rule scansnv_cigar_tuning:
    input:
        sc="{muttype}/{sample}/hsnp_spikein_cigars.tab",
        bulk="{muttype}/%s/hsnp_spikein_cigars.tab" % config['bulk_sample']
    output:
        "{muttype}/{sample}/cigar_tuning.rda"
    benchmark:
        "{muttype}/{sample}/benchmark_cigar_tuning.rda"
    resources:
        mem=1000
    script:
        "scripts/scansnv_cigar_tuning_script.R"


rule scansnv_fdr_tuning:
    input:
        mmq60="{muttype}/mmq60.tab",
        mmq1="{muttype}/mmq1.tab",
        hsnps=lambda wildcards:
            "ab_model/{sample}/training.rda" if wildcards.muttype == 'snv' or wildcards.muttype == "mosaic_snv" else "indel/{sample}/training.rda",
        som_sites=lambda wildcards:
            expand("{muttype}/somatic_positions.{chr_prefix}{chr}.tab",
                muttype=wildcards.muttype,
                chr_prefix=config['chr_prefix'],
                chr=config['chrs'])
    output:
        "{muttype}/{sample}/fdr_tuning.rda"
    params:
        sample="{sample}",
        bulk_sample=config['bulk_sample']
    resources:
        mem=5000
    benchmark:
        "{muttype}/{sample}/benchmark_fdr_tuning.tsv"
    shell:
        "{config[scripts]}/fdr_tuning.R"
        "   {input.mmq60} {input.mmq1}"
        "   {input.hsnps}"
        "   {params.bulk_sample} {params.sample}"
        "   {output} somatic"
        "   {config[min_sc_alt]} {config[min_sc_dp]} {config[min_bulk_dp]}"
        "   {input.som_sites}"


rule scansnv_genotype_scatter:
    input:
        mmq60="{muttype}/mmq60.tab",
        mmq1="{muttype}/mmq1.tab",
        som_ab="{muttype}/{sample}/{vartype}_ab.%s{chr}.rda" % config['chr_prefix'],
        sc_cigars="{muttype}/{sample}/{vartype}_cigars.%s{chr}.tab" % config['chr_prefix'],
        bulk_cigars="{muttype}/%s/{vartype}_cigars.%s{chr}.tab" % \
            (config['bulk_sample'], config['chr_prefix']),
        cigar_tuning="{muttype}/{sample}/cigar_tuning.rda",
        fdr_tuning="{muttype}/{sample}/fdr_tuning.rda",
    output:
        "{muttype}/{sample}/{vartype}_genotypes.%s{chr}.rda" % config['chr_prefix']
    params:
        sc_sample="{sample}",
        flag=lambda wildcards:
            'somatic' if wildcards.vartype == 'somatic' else 'spikein'
    resources:
        mem=5000
    benchmark:
        "{muttype}/{sample}/benchmark_{vartype}_genotypes.%s{chr}.tsv" % config['chr_prefix']
    shell:
        "{config[scripts]}/genotype.R"
        "   {input.mmq60} {input.mmq1}"
        "   {params.sc_sample} {config[bulk_sample]} {input.som_ab}"
        "   {input.sc_cigars} {input.bulk_cigars} {input.cigar_tuning}"
        "   {output} {config[target_fdr]} {input.fdr_tuning} {params.flag}"
        "   {config[min_sc_alt]} {config[min_sc_dp]} {config[min_bulk_dp]}"


rule scansnv_genotype_gather:
    input:
        lambda wildcards:
            expand("{muttype}/{sample}/{vartype}_genotypes.{chr_prefix}{chr}.rda",
                vartype=wildcards.vartype,
                muttype=wildcards.muttype,
                sample=wildcards.sample,
                chr_prefix=config['chr_prefix'],
                chr=config['chrs'])
    output:
        "{muttype}/{sample}/{vartype}_genotypes.rda"
    params:
        varname=lambda wildcards:
            'somatic' if wildcards.vartype == 'somatic' else 'spikeins',
    resources:
        mem=5000
    script:
        "scripts/scansnv_genotype_gather_script.R"


rule scansnv_indel_pon:
    input:
        rda="indel/{sample}/somatic_genotypes.rda"
    output:
        rda="indel/{sample}/somatic_genotypes.pon_filter.rda"
    resources:
        mem=6000
    benchmark:
        "indel/{sample}/benchmark_pon_filter.tsv"
    script:
        "scripts/scansnv_indel_pon_script.R"
