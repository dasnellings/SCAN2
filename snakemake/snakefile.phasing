# vim: syntax=python

'''
rule tabix_bulk_vcf:
    input:
        vcf="call_mutations/hc_raw.mmq60.exnonvar_biallelic_bulkcalled.bcf"
    output:
        vcfgz="call_mutations/hc_raw.mmq60.exnonvar_biallelic_bulkcalled.vcf.gz",
        idx="call_mutations/hc_raw.mmq60.exnonvar_biallelic_bulkcalled.vcf.gz.tbi"
    resources:
        mem_mb=4000
    shell:
        "bgzip -c {input.vcf} > {output.vcfgz} && tabix -p vcf {output.vcfgz}"
'''


rule phasing_phased_hsnps:
    input:
        config='scan.yaml',
        bulk_called_vcf="call_mutations/hc_raw.mmq60.exnonvar_biallelic_bulkcalled.bcf",
        bulk_called_vcf_idx="call_mutations/hc_raw.mmq60.exnonvar_biallelic_bulkcalled.bcf.csi",
        phased_hsnps_vcf=config['phased_hsnps']
    output:
        out_vcf=temp("phased_hsnps/phased_filtered.vcf"),
        out_vcf_gz="phased_hsnps/phased_filtered.vcf.gz",
        out_vcf_gz_tbi="phased_hsnps/phased_filtered.vcf.gz.tbi"
    log:
        "phased_hsnps/phased_filtered.log"
    params:
        genome=config['genome']
    threads: int(config['phased_hsnps_n_cores'])
    resources:
        mem_mb=lambda wildcards, input, threads: 4000 + threads*2000
    script:
        config['scripts'] + "/join_phased_hsnps.R"


rule phasing_gather_file_list:
    input:
        vcfs=expand("{phaser}/{chr}/phased_filtered.vcf",
            phaser=config['phaser'],
            chr=config['chrs'])
    output:
        filelist=temp("{phaser}/file_list.txt")
    localrule: True
    run:
        with open(output.filelist, 'w') as f:
            for vcf in input.vcfs:
                f.write(str(vcf) + "\n")


rule phasing_gather:
    input:
        filelist=config['phaser'] + "/file_list.txt"
    output:
        bcf=temp(config['phaser'] + "/phased_filtered.bcf"),
        bcfidx=temp(config['phaser'] + "/phased_filtered.bcf.csi"),
        #vcf=temp(config['phaser'] + "/phased_filtered.vcf"),
        #vcf_gz=config['phaser'] + "/phased_filtered.vcf.gz",
        #vcf_gz_idx=config['phaser'] + "/phased_filtered.vcf.gz.tbi",
    resources:
        mem_mb=200
    shell:
        """
        bcftools concat \
            --file-list {input.filelist} \
            -Ob -o {output.bcf}
        bcftools index -o {output.bcfidx} {output.bcf}
        """


rule shapeit_prepare:
    input:
        bcf="gatk/hc_raw.mmq60.bcf",
        bcfidx="gatk/hc_raw.mmq60.bcf.csi"
    output:
        vcf=temp("shapeit/{chr}/hc_raw.mmq60.{chr}.vcf")
    log:
        "shapeit/{chr}/prepare.log"
    benchmark:
        "shapeit/{chr}/benchmark_prepare.txt"
    params:
        chr="{chr}",
        bulk_sample=config['bulk_sample']
    resources:
        mem_mb=200
    shell:
        # bcftools method is md5sum-identical to the gatk SelectVariants method except
        # for the QUAL (6) and INFO (8) columns. Closer inspection shows the difference is
        # in number of signiciant digits written. E.g., where the GATK method reports a QUAL
        # score as "1929.80", the bcftools method reports "1929.8".
        #
        # (scan2dev) compute-a-16-171$ grep -v '^#' old_method_prepared.vcf|cut -f1-5,7,9,10|md5sum
        # 74fcb63714173ce1ca5259bcc1564fd6  -
        # (scan2dev) compute-a-16-171$ grep -v '^#' new_method_prepared.vcf|cut -f1-5,7,9,10|md5sum
        # 74fcb63714173ce1ca5259bcc1564fd6  -
        # 
        # second bcftools call: i can't get ALT != "." to work in the first call,
        # perhaps because ALT="." results from the application of --trim-alt-alleles.
        # not sure.
        """
        bcftools view \
            -s {params.bulk_sample} \
            -r {params.chr} \
            --trim-alt-alleles \
            --include '(TYPE="snp" | TYPE="indel") & N_ALT=1' \
            {input.bcf} \
        | bcftools view \
            --include 'ALT != "." & GT != "mis"' \
            -Ov -o {output.vcf}
        """


# this is almost identical to shapeit_prepare - the only difference is the final
# output is .vcf.gz instead of .vcf
rule eagle_prepare:
    input:
        "gatk/hc_raw.mmq60.bcf"
    output:
        vcfgz="eagle/{chr}/hc_raw.mmq60.{chr}.vcf.gz"
    params:
        chr="{chr}"
    resources:
        mem_mb=200
    shell:
        """
        bcftools view \
            -s {params.bulk_sample} \
            -r {params.chr} \
            --trim-alt-alleles \
            --include '(TYPE="snp" | TYPE="indel") & N_ALT=1' \
            {input.bcf} \
        | bcftools view \
            --include 'ALT != "." & GT != "mis"' \
            -Oz -o {output.vcfgz}
        tabix -pvcf {output.vcfgz}"
        """


rule shapeit_scatter:
    input:
        "shapeit/{chr}/hc_raw.mmq60.{chr}.vcf"
    output:
        temp("shapeit/{chr}/phased_filtered.vcf")
    log:
        "shapeit/{chr}/shapeit.log"
    benchmark:
        "shapeit/{chr}/benchmark_shapeit.tsv"
    params:
        excludefile="shapeit/{chr}/shapeit_check.snp.strand.exclude",
        tmpout="shapeit/{chr}/{chr}.phased",
        tmpout2=temp("shapeit/{chr}/phased.vcf"),
        checklog="shapeit/{chr}/shapeit_check.log",
        phaselog="shapeit/{chr}/shapeit_phase.log",
        convertlog="shapeit/{chr}/shapeit_convert.log",
        gmap="genetic_map_chr{chr}",
        hap="1000GP_Phase3_chr{chr}",
        leg="1000GP_Phase3_chr{chr}",
        # the genetic map is named genetic_map_chrX_nonPAR_combined_b37.txt
        gmap_extra_x=lambda wildcards: '_nonPAR' if wildcards.chr == 'X' else '',
        # the hap file is named 1000GP_Phase3_chrX_NONPAR.hap.gz
        extra_x=lambda wildcards: '_NONPAR' if wildcards.chr == 'X' else '',
        xflag=lambda wildcards: '--chrX' if wildcards.chr == 'X' else ''
    threads: 1
    resources:
        mem_mb=4000
    shell:
        # Note the "|| true" after shapeit -check: this is because shapeit
        # -check returns non-0 when it finds any number of problematic SNPs.
        # This CAN be dangerous as we're avoiding Snakemake's pipefail error
        # detection method.
        "shapeit -check"
        "    --input-vcf={input}"
        "    --output-log {params.checklog}"
        "    --seed 1649118769"
        "    -M {config[shapeit_refpanel]}/{params.gmap}{params.gmap_extra_x}_combined_b37.txt"
        "    --input-ref {config[shapeit_refpanel]}/{params.hap}{params.extra_x}.hap.gz"
        "        {config[shapeit_refpanel]}/{params.leg}{params.extra_x}.legend.gz "
        "        {config[shapeit_refpanel]}/1000GP_Phase3.sample || true ; "
        "shapeit"
        "    --thread {threads}"
        "    --input-vcf={input}"
        "    --output-log {params.phaselog}"
        "    --seed 1649118772"
        "    -M {config[shapeit_refpanel]}/{params.gmap}{params.gmap_extra_x}_combined_b37.txt"
        "    --input-ref {config[shapeit_refpanel]}/{params.hap}{params.extra_x}.hap.gz"
        "        {config[shapeit_refpanel]}/{params.leg}{params.extra_x}.legend.gz "
        "        {config[shapeit_refpanel]}/1000GP_Phase3.sample"
        "    --exclude-snp {params.excludefile}"
        "    {params.xflag}"
        "    -O {params.tmpout} ; "
        "shapeit -convert "
        "    --seed 1649118812"
        "    --output-log {params.convertlog}"
        "    --input-haps {params.tmpout} --output-vcf {params.tmpout2} ; "
        "(grep '^#' {input} | grep -v '^#CHROM' ; "
        " grep '^##source' {params.tmpout2} ; "
        " awk '$10 == \"1|1\" || $10 == \"1|0\" || $10 == \"0|1\" || $1 ~ /^#/' {params.tmpout2}"
        "    | sed -e\"s/^\(#CHROM.*\){config[bulk_sample]}/\\1phasedgt/g\" "
        "    | grep '^[^#]\|^#CHROM' ) > {output}"
        # These last few greps are necessary for preserving the original VCF
        # header, which some tools are strict about. SHAPEIT2 does not provide
        # a header with the required annotations. The second grep also
        # preserves the SHAPEIT version info (##source).
    

rule eagle_scatter:
    input:
        "eagle/{chr}/hc_raw.mmq60.{chr}.vcf.gz"
    output:
        "eagle/{chr}/phased_filtered.vcf"
    params:
        tmpout="eagle/{chr}/phased_hsnps_tmp.vcf",
        zippedinput="eagle/{chr}/hc_raw.mmq60.{chr}.vcf.gz",
        refbcf=lambda wildcards:
            config['eagle_refpanel'][wildcards.chr],
        outprefix="eagle/{chr}/phased_hsnps_tmp"
    benchmark:
        "eagle/{chr}/benchmark.tsv"
    resources:
        mem_mb=8000
    shell:
        """
        eagle --vcfTarget {params.zippedinput} \
            --vcfRef {params.refbcf} \
            --geneticMapFile {config[eagle_genmap]} \
            --vcfOutFormat v \
            --outPrefix {params.outprefix} ;
        awk 'BEGIN {{ OFS="\t"; }} {{ if ($1 ~ /^#/) {{ print $0; }}; if ($10 ~ /^1\|1/ || $10 ~ /^1\|0/ || $10 ~ /^0\|1/) {{ split($10, gt, ":"); $10 = gt[1]; print $0; }} }}' {params.tmpout} \
             | sed -e\"s/^\(#CHROM.*\){config[bulk_sample]}/\\1phasedgt/g\" > {output}
        """
        # Unlike SHAPEIT, Eagle does preserve header info. We just need to
        # change the sample name and only retain phased sites. Eagle outputs
        # more than just the genotype string (0|1 or 1|0), so delete the extra
        # info.
