# vim: syntax=python

rule gatk_gather:
    input:
        vcfs=lambda wildcards:
                expand("gatk/hc_raw.mmq{gatk_mmq}_chunk{gatk_chunk}.vcf",
                       gatk_mmq=wildcards.gatk_mmq,
                       gatk_chunk=range(1, config['gatk_chunks']+1))
    output:
        vcf="gatk/hc_raw.mmq{gatk_mmq}.vcf"
    params:
        lambda wildcards, input:
            ' '.join([ "-I " + f for f in input ])
    resources:
        mem_mb=4000
    benchmark:
        "gatk/gather_benchmark.mmq{gatk_mmq}.tsv"
    shell:
        "gatk GatherVcfs "
        "    --java-options '-Xmx3G -Xms3G'"
        "    {params} "
        "    -R {config[ref]}"
        "    -O {output.vcf}"


rule gatk_genotypegvcfs:
    input:
        gvcf="gatk/hc_raw.mmq{gatk_mmq}_chunk{gatk_chunk}.gvcf.gz"
    output:
        vcf="gatk/hc_raw.mmq{gatk_mmq}_chunk{gatk_chunk}.vcf"
    params:
        memreq=lambda wildcards, input, output, threads, resources: str(int(resources.mem_mb/2) - 500) + "M"
    benchmark:
        "gatk/genotypegvcfs_benchmark.mmq{gatk_mmq}_chunk{gatk_chunk}.tsv"
    resources:
        mem_mb=8000
    shell:
        "gatk GenotypeGVCFs"
        "   --java-options '-Xmx{params.memreq} -Xms{params.memreq}'"
        "   --dbsnp {config[dbsnp]}"
        "   -R {config[ref]}"
        "   -V {input}"
        "   -O {output}"


rule gatk_combinegvcfs:
    input:
        gvcfs=lambda wildcards:
                expand("gatk/{sample}/hc_raw.mmq{gatk_mmq}_chunk{{gatk_chunk}}.gvcf.gz",
                       sample=config['bam_map'].keys(),
                       gatk_mmq=wildcards.gatk_mmq,
                       gatk_chunk=range(1, config['gatk_chunks']+1))
    output:
        "gatk/hc_raw.mmq{gatk_mmq}_chunk{gatk_chunk}.gvcf.gz"
    benchmark:
        "gatk/combinegvcfs_benchmark.mmq{gatk_mmq}_chunk{gatk_chunk}.tsv"
    params:
        infiles=lambda wildcards, input:
            ' '.join([ "--variant " + f for f in input ]),
        memreq=lambda wildcards, input, output, threads, resources: str(int(resources.mem_mb/2) - 500) + "M"
    threads: 1
    resources:
        mem_mb=8000
    shell:
        "gatk CombineGVCFs"
        "   --java-options '-Xmx{params.memreq} -Xms{params.memreq}'"
        "   -R {config[ref]}"
        "   {params.infiles}"
        "   -O {output}"


rule gatk_scatter:
    input:
        bam=lambda wildcards: config['bam_map'][wildcards.sample]
    output:
        gvcf="gatk/{sample}/hc_raw.mmq{gatk_mmq}_chunk{gatk_chunk}.gvcf.gz"
    params:
        regionflag=lambda wildcards:
            "-L " + config['gatk_regions'][int(wildcards.gatk_chunk) - 1],
        mmq="{gatk_mmq}",
        # allocate half of the memory to stack, half to heap
        # it seems some JVMs allocate this memory immediately, whether used by
        # the program or not. so we subtract 1000MB (500 from stack and heap
        # each) from the total to ensure that the job isn't immediately killed
        # by the cluster scheduler.
        memreq=lambda wildcards, input, output, threads, resources: str(int(resources.mem_mb/2) - 500) + "M"
    resources:
        mem_mb=4000
    benchmark:
        "gatk/{sample}/scatter_benchmark.mmq{gatk_mmq}_chunk{gatk_chunk}.tsv"
    shell:
        "gatk HaplotypeCaller"
        "    --java-options '-Xmx{params.memreq} -Xms{params.memreq}'"
        "    --dont-use-soft-clipped-bases"
        "    --dbsnp {config[dbsnp]}"
        "    --minimum-mapping-quality {params.mmq}"
        "    --emit-ref-confidence BP_RESOLUTION"
        "    --min-base-quality-score {config[min_base_quality_score]}"
        "    {params.regionflag}"
        "    -R {config[ref]}"
        "    -I {input}"
        "    -O {output}"
